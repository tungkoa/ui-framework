"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.denoifySingleFileFactory = void 0;
const replaceAsync_1 = require("../tools/replaceAsync");
const crypto = require("crypto");
const index_1 = require("./builtins/index");
/**
 * Remove any lines containing and following // @denoify-line-ignore
 */
const IGNORE_LINE_COMMENT = /^\/\/\s+@denoify-line-ignore/;
function dealWithDenoifyLineIgnoreSpecialComment(sourceCode) {
    let previousLineHadIgnoreComment = false;
    return sourceCode
        .split("\n")
        .filter(line => {
        const thisLineHasIgnoreComment = IGNORE_LINE_COMMENT.test(line);
        const skipThisLine = thisLineHasIgnoreComment || previousLineHadIgnoreComment;
        if (previousLineHadIgnoreComment) {
            previousLineHadIgnoreComment = false;
        }
        if (thisLineHasIgnoreComment) {
            previousLineHadIgnoreComment = thisLineHasIgnoreComment;
        }
        return !skipThisLine;
    })
        .join("\n");
}
function denoifySingleFileFactory(params) {
    const { denoifyImportExportStatement } = params;
    /** Returns source code with deno imports replaced */
    async function denoifySingleFile(params) {
        const { dirPath, sourceCode } = params;
        // Handle ignore comments
        let modifiedSourceCode = dealWithDenoifyLineIgnoreSpecialComment(sourceCode);
        // Add support for Node builtins
        for (const builtin of index_1.default) {
            if (builtin.test(modifiedSourceCode)) {
                modifiedSourceCode = [...builtin.modification, modifiedSourceCode].join("\n");
            }
        }
        // Cleanup import/export statements
        const denoifiedImportExportStatementByHash = new Map();
        for (const quoteSymbol of [`"`, `'`]) {
            const strRegExpInQuote = `${quoteSymbol}[^${quoteSymbol}\\r\\n]+${quoteSymbol}`;
            for (const regExpStr of [
                ...[
                    `export\\s+\\*\\s+from\\s*${strRegExpInQuote}`,
                    `(?:import|export)(?:\\s+type)?\\s*\\*\\s*as\\s+[^\\s]+\\s+from\\s*${strRegExpInQuote}`,
                    `(?:import|export)(?:\\s+type)?\\s*{[^}]*}\\s*from\\s*${strRegExpInQuote}`,
                    `import(?:\\s+type)?\\s+[^\\*{][^\\s]*\\s*(?:,\\s*{[^}]*})?\\s+from\\s*${strRegExpInQuote}`,
                    `import\\s*${strRegExpInQuote}`,
                    `declare\\s+module\\s+${strRegExpInQuote}`
                ].map(s => `(?<=^|[\\r\\n\\s;])(?<! \\* )${s}`),
                `(?<=[^a-zA-Z\._0-9$\*])import\\s*\\(\\s*${strRegExpInQuote}\\s*\\)` //type Foo = import("...").Foo
            ]) {
                modifiedSourceCode = await (0, replaceAsync_1.replaceAsync)(modifiedSourceCode, new RegExp(regExpStr, "g"), async (importExportStatement) => {
                    const denoifiedImportExportStatement = await denoifyImportExportStatement({
                        dirPath,
                        importExportStatement
                    });
                    const hash = crypto.createHash("sha256").update(denoifiedImportExportStatement).digest("hex");
                    denoifiedImportExportStatementByHash.set(hash, denoifiedImportExportStatement);
                    return hash;
                });
            }
        }
        for (const [hash, denoifiedImportExportStatement] of denoifiedImportExportStatementByHash) {
            modifiedSourceCode = modifiedSourceCode.replace(new RegExp(hash, "g"), denoifiedImportExportStatement);
        }
        return modifiedSourceCode;
    }
    return { denoifySingleFile };
}
exports.denoifySingleFileFactory = denoifySingleFileFactory;
//# sourceMappingURL=denoifySingleFile.js.map