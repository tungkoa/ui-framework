/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * Copyright(c) 2021 Yannick Deubel (https://github.com/yandeu)
 * MIT Licensed
 */
import finalhandler from 'finalhandler';
import methods from 'methods';
import _debug from 'debug';
import { View } from './view.js';
import http from 'http';
import { applyMixins, compileETag, compileQueryParser, compileTrust } from './utils.js';
import { flatten } from 'array-flatten';
import merge from 'utils-merge';
import { resolve } from 'path';
import { EventEmitter } from 'events';
import { res as response } from './response.js';
import { req as request } from './request.js';
import { ExtensibleFunction } from './utils.js';
const debug = _debug('express:application');
const slice = Array.prototype.slice;
/** Variable for trust proxy inheritance back-compat */
const trustProxyDefaultSymbol = '@@symbol:trust_proxy_default';
class Express extends ExtensibleFunction {
    constructor() {
        super((req, res, next) => {
            return this.handle(req, res, next);
        });
        this.cache = {};
        this.engines = {};
        this.settings = {};
        // expose the prototype that will get set on requests
        this.request = request;
        // expose the prototype that will get set on responses
        this.response = response;
        this.init();
    }
    init() {
        this.cache = {};
        this.engines = {};
        this.settings = {};
        this.defaultConfiguration();
    }
    /** Initialize application configuration. */
    defaultConfiguration() {
        const env = process.env.NODE_ENV || 'development';
        // default settings
        this.enable('x-powered-by');
        this.set('etag', 'weak');
        this.set('env', env);
        this.set('query parser', 'extended');
        this.set('subdomain offset', 2);
        this.set('trust proxy', false);
        // trust proxy inherit back-compat
        Object.defineProperty(this.settings, trustProxyDefaultSymbol, {
            configurable: true,
            value: true
        });
        debug('booting in %s mode', env);
        this.on('mount', function onmount(parent) {
            // inherit trust proxy
            if (this.settings[trustProxyDefaultSymbol] === true && typeof parent.settings['trust proxy fn'] === 'function') {
                delete this.settings['trust proxy'];
                delete this.settings['trust proxy fn'];
            }
            // inherit protos
            Object.setPrototypeOf(this.request, parent.request);
            Object.setPrototypeOf(this.response, parent.response);
            Object.setPrototypeOf(this.engines, parent.engines);
            Object.setPrototypeOf(this.settings, parent.settings);
        });
        // setup locals
        this.locals = Object.create(null);
        // top-most app is mounted at /
        this.mountpath = '/';
        // default locals
        this.locals.settings = this.settings;
        // default configuration
        this.set('view', View);
        this.set('views', resolve('views'));
        this.set('jsonp callback name', 'callback');
        if (env === 'production') {
            this.enable('view cache');
        }
    }
    /**
     * Dispatch a req, res pair into the application. Starts pipeline processing.
     *
     * If no callback is provided, then default error handlers will respond
     * in the event of an error bubbling through the stack.
     */
    handle(req, res, callback) {
        // @ts-ignore
        req.__proto__ = request;
        // @ts-ignore
        res.__proto__ = response;
        // set circular references
        req.res = res;
        res.req = req;
        // @ts-ignore
        res.app = this;
        // @ts-ignore
        req.app = this;
        // final handler
        const done = callback ||
            finalhandler(req, res, {
                env: this.get('env'),
                onerror: logerror.bind(this)
            });
        // set powered by header
        if (this.enabled('x-powered-by')) {
            res.setHeader('X-Powered-By', 'Express');
        }
        // setup locals
        if (!res.locals) {
            res.locals = Object.create(null);
        }
        // @ts-ignore
        this.router.handle(req, res, done);
    }
    use(fn) {
        let offset = 0;
        let path = '/';
        // default path to '/'
        // disambiguate app.use([fn])
        if (typeof fn !== 'function') {
            let arg = fn;
            while (Array.isArray(arg) && arg.length !== 0) {
                arg = arg[0];
            }
            // first arg is the path
            if (typeof arg !== 'function') {
                offset = 1;
                path = fn;
            }
        }
        const fns = flatten(slice.call(arguments, offset));
        if (fns.length === 0) {
            throw new TypeError('app.use() requires a middleware function');
        }
        return this;
    }
    /**
     * Register the given template engine callback `fn`
     * as `ext`.
     *
     * By default will `require()` the engine based on the
     * file extension. For example if you try to render
     * a "foo.ejs" file Express will invoke the following internally:
     *
     *     app.engine('ejs', require('ejs').__express);
     *
     * For engines that do not provide `.__express` out of the box,
     * or if you wish to "map" a different extension to the template engine
     * you may use this method. For example mapping the EJS template engine to
     * ".html" files:
     *
     *     app.engine('html', require('ejs').renderFile);
     *
     * In this case EJS provides a `.renderFile()` method with
     * the same signature that Express expects: `(path, options, callback)`,
     * though note that it aliases this method as `ejs.__express` internally
     * so if you're using ".ejs" extensions you don't need to do anything.
     *
     * Some template engines do not follow this convention, the
     * [Consolidate.js](https://github.com/tj/consolidate.js)
     * library was created to map all of node's popular template
     * engines to follow this convention, thus allowing them to
     * work seamlessly within Express.
     */
    engine(ext, fn) {
        if (typeof fn !== 'function') {
            throw new Error('callback function required');
        }
        // get file extension
        const extension = ext[0] !== '.' ? `.${ext}` : ext;
        // store engine
        this.engines[extension] = fn;
        return this;
    }
    /**
     * Assign `setting` to `val`, or return `setting`'s value.
     *
     *    app.set('foo', 'bar');
     *    app.set('foo');
     *    // => "bar"
     *
     * Mounted servers inherit their parent server's settings.
     */
    set(setting, val) {
        if (arguments.length === 1) {
            // app.get(setting)
            return this.settings[setting];
        }
        debug('set "%s" to %o', setting, val);
        // set value
        this.settings[setting] = val;
        // trigger matched settings
        switch (setting) {
            case 'etag':
                this.set('etag fn', compileETag(val));
                break;
            case 'query parser':
                this.set('query parser fn', compileQueryParser(val));
                break;
            case 'trust proxy':
                this.set('trust proxy fn', compileTrust(val));
                // trust proxy inherit back-compat
                Object.defineProperty(this.settings, trustProxyDefaultSymbol, {
                    configurable: true,
                    value: false
                });
                break;
        }
        return this;
    }
    /**
     * Return the app's absolute pathname
     * based on the parent(s) that have
     * mounted it.
     *
     * For example if the application was
     * mounted as "/admin", which itself
     * was mounted as "/blog" then the
     * return value would be "/blog/admin".
     */
    path() {
        return this.parent ? this.parent.path() + this.mountpath : '';
    }
    /**
     * Check if `setting` is enabled (truthy).
     *
     *    app.enabled('foo')
     *    // => false
     *
     *    app.enable('foo')
     *    app.enabled('foo')
     *    // => true
     */
    enabled(setting) {
        return Boolean(this.set(setting));
    }
    /**
     * Check if `setting` is disabled.
     *
     *    app.disabled('foo')
     *    // => true
     *
     *    app.enable('foo')
     *    app.disabled('foo')
     *    // => false
     */
    disabled(setting) {
        return !this.set(setting);
    }
    /** Enable `setting`. */
    enable(setting) {
        return this.set(setting, true);
    }
    /** Disable `setting`. */
    disable(setting) {
        return this.set(setting, false);
    }
    /**
     * Render the given view `name` name with `options`
     * and a callback accepting an error and the
     * rendered template string.
     *
     * Example:
     *
     *    app.render('email', { name: 'Tobi' }, function(err, html){
     *      // ...
     *    })
     */
    render(name, options, callback) {
        const cache = this.cache;
        let done = callback;
        const engines = this.engines;
        let opts = options;
        const renderOptions = {};
        let view;
        // support callback function as second arg
        if (typeof options === 'function') {
            done = options;
            opts = {};
        }
        // merge app.locals
        merge(renderOptions, this.locals);
        // merge options._locals
        if (opts._locals) {
            merge(renderOptions, opts._locals);
        }
        // merge options
        merge(renderOptions, opts);
        // set .cache unless explicitly provided
        if (renderOptions.cache == null) {
            renderOptions.cache = this.enabled('view cache');
        }
        // primed cache
        if (renderOptions.cache) {
            view = cache[name];
        }
        // view
        if (!view) {
            const View = this.get('view');
            view = new View(name, {
                defaultEngine: this.get('view engine'),
                root: this.get('views'),
                engines: engines
            });
            if (!view.path) {
                const dirs = Array.isArray(view.root) && view.root.length > 1
                    ? `directories "${view.root.slice(0, -1).join('", "')}" or "${view.root[view.root.length - 1]}"`
                    : `directory "${view.root}"`;
                const err = new Error(`Failed to lookup view "${name}" in views ${dirs}`);
                // @ts-ignore
                err.view = view;
                return done(err);
            }
            // prime the cache
            if (renderOptions.cache) {
                cache[name] = view;
            }
        }
        // render
        tryRender(view, renderOptions, done);
    }
    listen(...args) {
        const server = http.createServer(this);
        return server.listen(...args);
    }
}
/** Delegate `.VERB(...)` calls to `router.VERB(...)`. */
methods.forEach(function (method) {
    Express.prototype[method] = function (...path) {
        if (method === 'get' && arguments.length === 1) {
            // app.get(setting)
            return this.set(path[0]);
        }
        const route = this.router.route(path[0]);
        // eslint-disable-next-line prefer-spread
        route[method].apply(route, slice.call(path, 1));
        return this;
    };
});
/**
 * Log error using console.error.
 *
 * @param {Error} err
 * @private
 */
function logerror(err) {
    /* istanbul ignore next */
    if (this.get('env') !== 'test')
        console.error(err.stack || err.toString());
}
/**
 * Try rendering a view.
 * @private
 */
function tryRender(view, options, callback) {
    try {
        view.render(options, callback);
    }
    catch (err) {
        callback(err);
    }
}
applyMixins(Express, [EventEmitter]);
export default Express;
export { Express as app2 };
//# sourceMappingURL=app2.js.map