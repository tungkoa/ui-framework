/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * Copyright(c) 2021 Yannick Deubel (https://github.com/yandeu)
 * MIT Licensed
 */
/// <reference types="node" />
import type { GetSettings, RESTFunction, Request, RequestHandler, Response } from './types.js';
import { EventEmitter } from 'events';
import { ExtensibleFunction } from './utils.js';
import http from 'http';
declare class Express extends ExtensibleFunction<RequestHandler> {
    cache: any;
    engines: any;
    settings: any;
    locals: any;
    mountpath: string;
    parent: any;
    request: Request;
    response: Response;
    private _router;
    get: GetSettings | RESTFunction;
    post: RESTFunction;
    put: RESTFunction;
    patch: RESTFunction;
    delete: RESTFunction;
    copy: RESTFunction;
    head: RESTFunction;
    options: RESTFunction;
    constructor();
    /**
     * Initialize the server.
     *
     *   - setup default configuration
     *   - setup default middleware
     *   - setup route reflection methods
     */
    private init;
    /** Initialize application configuration. */
    private defaultConfiguration;
    /** Getting lazily added base router. */
    get router(): any;
    /**
     * Dispatch a req, res pair into the application. Starts pipeline processing.
     *
     * If no callback is provided, then default error handlers will respond
     * in the event of an error bubbling through the stack.
     */
    private handle;
    /**
     * Proxy `Router#use()` to add middleware to the app router.
     * See Router#use() documentation for details.
     *
     * If the _fn_ parameter is an express app, then it will be
     * mounted at the _route_ specified.
     */
    use(path: string, ...handlers: RequestHandler[]): any;
    use(...handlers: RequestHandler[]): any;
    /**
     * Proxy to the app `Router#route()`
     * Returns a new `Route` instance for the _path_.
     *
     * Routes are isolated middleware stacks for specific paths.
     * See the Route api docs for details.
     */
    route(path: any): any;
    /**
     * Register the given template engine callback `fn`
     * as `ext`.
     *
     * By default will `require()` the engine based on the
     * file extension. For example if you try to render
     * a "foo.ejs" file Express will invoke the following internally:
     *
     *     app.engine('ejs', require('ejs').__express);
     *
     * For engines that do not provide `.__express` out of the box,
     * or if you wish to "map" a different extension to the template engine
     * you may use this method. For example mapping the EJS template engine to
     * ".html" files:
     *
     *     app.engine('html', require('ejs').renderFile);
     *
     * In this case EJS provides a `.renderFile()` method with
     * the same signature that Express expects: `(path, options, callback)`,
     * though note that it aliases this method as `ejs.__express` internally
     * so if you're using ".ejs" extensions you don't need to do anything.
     *
     * Some template engines do not follow this convention, the
     * [Consolidate.js](https://github.com/tj/consolidate.js)
     * library was created to map all of node's popular template
     * engines to follow this convention, thus allowing them to
     * work seamlessly within Express.
     */
    engine(ext: string, fn: Function): this;
    /**
     * Proxy to `Router#param()` with one added api feature. The _name_ parameter
     * can be an array of names.
     *
     * See the Router#param() docs for more details.
     */
    param(name: string | any[], fn: Function): this;
    /**
     * Assign `setting` to `val`, or return `setting`'s value.
     *
     *    app.set('foo', 'bar');
     *    app.set('foo');
     *    // => "bar"
     *
     * Mounted servers inherit their parent server's settings.
     */
    set(setting: string, val?: any): this;
    /**
     * Return the app's absolute pathname
     * based on the parent(s) that have
     * mounted it.
     *
     * For example if the application was
     * mounted as "/admin", which itself
     * was mounted as "/blog" then the
     * return value would be "/blog/admin".
     */
    private path;
    /**
     * Check if `setting` is enabled (truthy).
     *
     *    app.enabled('foo')
     *    // => false
     *
     *    app.enable('foo')
     *    app.enabled('foo')
     *    // => true
     */
    enabled(setting: string): boolean;
    /**
     * Check if `setting` is disabled.
     *
     *    app.disabled('foo')
     *    // => true
     *
     *    app.enable('foo')
     *    app.disabled('foo')
     *    // => false
     */
    disabled(setting: string): boolean;
    /** Enable `setting`. */
    enable(setting: string): this;
    /** Disable `setting`. */
    disable(setting: string): this;
    /**
     * Special-cased "all" method, applying the given route `path`,
     * middleware, and callback to _every_ HTTP method.
     */
    all(path: string, ...handlers: RequestHandler[]): this;
    /**
     * Render the given view `name` name with `options`
     * and a callback accepting an error and the
     * rendered template string.
     *
     * Example:
     *
     *    app.render('email', { name: 'Tobi' }, function(err, html){
     *      // ...
     *    })
     */
    render(name: string, options: Object | Function, callback: Function): void;
    /**
     * Listen for connections.
     *
     * A node `http.Server` is returned, with this
     * application (which is a `Function`) as its
     * callback. If you wish to create both an HTTP
     * and HTTPS server you may do so with the "http"
     * and "https" modules as shown here:
     *
     *    let http = require('http')
     *      , https = require('https')
     *      , express = require('express')
     *      , app = express();
     *
     *    http.createServer(app).listen(80);
     *    https.createServer({ ... }, app).listen(443);
     */
    listen(port?: number | undefined, listeningListener?: () => void): http.Server;
    listen(port?: number | undefined, hostname?: string | undefined, backlog?: number | undefined, listeningListener?: () => void): http.Server;
}
/** Create an express application. */
interface Express extends EventEmitter {
}
export default Express;
export { Express };
