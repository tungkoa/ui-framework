import { isPromise, isRegExp } from 'util/types';
import { ExtensibleFunction } from '../utils.js';
const rm = {
    slash: {
        double: (str) => str.replace(/\/\/+/gm, '/'),
        start: (str) => str.replace(/^\/+/gm, '')
    }
};
/** check if path matches url (string only) */
const matchPath = (path, url) => {
    // if (path === url) return true
    const p = path;
    const u = splitPath(url);
    if (p.length > p.length)
        return false;
    const params = new Map();
    const isParam = (p, u) => {
        if (typeof p !== 'string')
            return false;
        if (p[0] !== ':')
            return false;
        const param = p.substring(1);
        params.set(param, u);
        return true;
    };
    /**
     * @param p route path
     * @param u url path
     */
    const compare = (p, u) => {
        return p === u || isParam(p, u) || (isRegExp(p) && u.match(p) !== null);
    };
    let i = 0;
    while (u[i] && compare(p[i], u[i])) {
        i++;
    }
    const match = compare(p[i], u[i]);
    if (params.size > 0)
        return params;
    return match;
};
// type RequestHandlerCtx = (c: RequestHandler) => void
const splitPath = (path) => {
    return rm.slash.start(path).split('/');
};
export class Router extends ExtensibleFunction {
    constructor(route) {
        super((req, res, next) => {
            return this.handle(req, res, next);
        });
        this.route = route;
        this.children = [];
        this.paths = [];
        this._isChild = false;
    }
    get isChild() {
        return this._isChild;
    }
    toTree() {
        // TODO(yandeu): improve this
        const branches = [];
        this.paths.forEach(p => {
            const arr = [...p.path];
            // @ts-ignore
            const branch = arr.reverse().reduce((res, key) => ({ [key]: res }), {});
            branches.push(branch);
        });
        this.children.forEach(c => {
            c.paths.forEach(p => {
                const arr = [...p.path];
                // @ts-ignore
                const branch = arr.reverse().reduce((res, key) => ({ [key]: res }), {});
                branches.push(branch);
            });
        });
        let tree = {};
        branches.forEach(b => {
            tree = { ...tree, ...b };
        });
        return branches;
    }
    handle(req, res, next) {
        return this.handler(req, res, next);
    }
    async handler(req, res, next) {
        const callHandler = async (handler) => {
            // is RequestHandler or HandlerCtx
            const isCtx = handler.length === 1;
            let nextWrapper;
            const p = new Promise(resolve => {
                nextWrapper = resolve;
            });
            //   const nextWrapper: any = (arg: any) => {
            //     if (isAsync) return
            //     console.log('arg', arg)
            //   }
            try {
                let fnc;
                if (isCtx)
                    fnc = handler({ req, res, next: nextWrapper });
                else
                    fnc = handler(req, res, nextWrapper);
                if (isPromise(fnc)) {
                    nextWrapper();
                    const result = await fnc;
                    //console.log('FNC => ', result)
                    //   if (typeof result !== 'undefined') return result
                }
                else {
                    const result = await p;
                    // console.log('NEXT =>', result)
                    //   if (typeof result !== 'undefined') return result
                }
            }
            catch (err) {
                console.log('Error:', err.message);
            }
        };
        let finished = false;
        const checkPaths = async function (paths) {
            for (let i = 0; i < paths.length; i++) {
                const p = paths[i];
                if (p.isMiddleware) {
                    const result = await callHandler(p.handler);
                    if (typeof result !== 'undefined') {
                        finished = true;
                        break;
                    }
                }
                const match = matchPath(p.path, req.url);
                if (match !== false) {
                    if (typeof match !== 'boolean')
                        req.params = Object.fromEntries(match);
                    const result = await callHandler(p.handler);
                    if (typeof result !== 'undefined') {
                        finished = true;
                        break;
                    }
                }
            }
        };
        // check children first
        for (let i = 0; i < this.children.length; i++) {
            await checkPaths(this.children[i].paths);
        }
        // check path of this router
        if (!finished)
            await checkPaths(this.paths);
        if (next)
            next();
    }
    registerRoute(method, path, handler) {
        let _path;
        if (typeof path === 'string')
            _path = splitPath(path);
        else
            _path = [path];
        const toPathTree = (...path) => {
            const p = path.map(p => {
                if (typeof p === 'string')
                    return rm.slash.start(p);
                else
                    return p;
            });
            return p.filter(p => p !== '');
        };
        const p = toPathTree(this.route, ..._path);
        this.paths.push({ path: p, method: method.toLowerCase(), handler, isMiddleware: method.toLowerCase() === 'use' });
    }
    GET(path, handler) {
        this.registerRoute('get', path, handler);
    }
    use(paramOne, paramTwo) {
        if (typeof paramOne === 'string' && typeof paramTwo === 'function')
            this.registerRoute('use', paramOne, paramTwo);
        else if (typeof paramOne === 'function')
            this.registerRoute('use', this.route, paramOne);
    }
    add(...router) {
        router.forEach(r => (r._isChild = true));
        this.children.push(...router);
    }
}
//# sourceMappingURL=router.js.map