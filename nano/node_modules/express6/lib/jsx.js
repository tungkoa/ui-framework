"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DocumentSSR = exports.HTMLElementSSR = exports.render = exports.initSSR = void 0;
const escape_html_1 = __importDefault(require("escape-html"));
const jsx_core_1 = require("./jsx.core");
__exportStar(require("./jsx.core"), exports);
const initSSR = (pathname = '/') => {
    // set pathname
    __jsx.location = { pathname };
    // @ts-ignore
    __jsx.document = new DocumentSSR();
};
exports.initSSR = initSSR;
const render = (component, options = {}) => {
    const { pathname } = options;
    (0, exports.initSSR)(pathname);
    return (0, jsx_core_1.render)(component, null, true).join('');
};
exports.render = render;
class HTMLElementSSR {
    constructor(tag) {
        this.isSelfClosing = false;
        this.tagName = tag;
        const selfClosing = [
            'area',
            'base',
            'br',
            'col',
            'embed',
            'hr',
            'img',
            'input',
            'link',
            'meta',
            'param',
            'source',
            'track',
            'wbr'
        ];
        if (selfClosing.indexOf(tag) >= 0) {
            this.ssr = `<${tag} />`;
            this.isSelfClosing = true;
        }
        else {
            this.ssr = `<${tag}></${tag}>`;
        }
    }
    static isHtmlElement(str) {
        return /<(?<tag>\w+)[^>]+>[^<]+<\/(\k<tag>)>|<[^>]+\/>/.test(str);
    }
    get outerHTML() {
        return this.innerText;
    }
    get innerHTML() {
        var _a, _b;
        const reg = /(^<[a-z]+>)([\s\S]*)(<\/[a-z]+>$)/gm;
        return (_b = (_a = reg.exec(this.ssr)) === null || _a === void 0 ? void 0 : _a[2]) !== null && _b !== void 0 ? _b : '';
    }
    get innerText() {
        var _a, _b;
        const reg = /(^<[^>]+>)(.+)?(<\/[a-z]+>$|\/>$)/gm;
        return (_b = (_a = reg.exec(this.ssr)) === null || _a === void 0 ? void 0 : _a[2]) !== null && _b !== void 0 ? _b : '';
    }
    set innerText(text) {
        const reg = /(^<[^>]+>)(.+)?(<\/[a-z]+>$|\/>$)/gm;
        this.ssr = this.ssr.replace(reg, `$1${text}$3`);
    }
    get attributes() {
        return { length: 1 };
    }
    setAttributeNS(name, value) {
        this.setAttribute(name, value);
    }
    setAttribute(name, value) {
        if (this.isSelfClosing)
            this.ssr = this.ssr.replace(/(^<[a-z]+ )(.+)/gm, `$1${(0, escape_html_1.default)(name)}="${(0, escape_html_1.default)(value)}" $2`);
        else
            this.ssr = this.ssr.replace(/(^<[^>]+)(.+)/gm, `$1 ${(0, escape_html_1.default)(name)}="${(0, escape_html_1.default)(value)}"$2`);
    }
    appendChild(child) {
        const append = child.ssr ? child.ssr : child;
        const index = this.ssr.lastIndexOf('</');
        this.ssr = this.ssr.substring(0, index) + append + this.ssr.substring(index);
    }
    replaceChild(newChild, _oldChild) {
        this.innerText = newChild.ssr;
    }
    get children() {
        const reg = /<([a-z]+)((?!<\/\1).)*<\/\1>/gms;
        const array = [];
        let match;
        while ((match = reg.exec(this.innerHTML)) !== null) {
            array.push(match[0].replace(/[\s]+/gm, ' '));
        }
        return array;
    }
    addEventListener(_type, _listener, _options) { }
}
exports.HTMLElementSSR = HTMLElementSSR;
class DocumentSSR {
    constructor() {
        this.body = this.createElement('body');
        this.head = this.createElement('head');
    }
    createElement(tag) {
        return new HTMLElementSSR(tag);
    }
    createElementNS(_URI, tag) {
        return new HTMLElementSSR(tag);
    }
    createTextNode(text) {
        return text;
    }
    querySelector(_query) {
        return undefined;
    }
}
exports.DocumentSSR = DocumentSSR;
globalThis.__jsx = { location: { pathname: '/' }, document: new DocumentSSR() };
//# sourceMappingURL=jsx.js.map