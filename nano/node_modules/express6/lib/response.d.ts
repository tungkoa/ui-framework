/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * Copyright(c) 2021 Yannick Deubel (https://github.com/yandeu)
 * MIT Licensed
 */
/// <reference types="node" />
import type { Express } from './application.js';
import { Request } from './types.js';
import { ServerResponse } from 'http';
declare class Response extends ServerResponse {
    req: Request;
    app: Express;
    locals: any;
    /** Set status `code`. */
    status(code: number): this;
    /**
     * Set Link header field with the given `links`.   *
     * @example
     * res.links({
     *   next: 'http://api.example.com/users?page=2',
     *   last: 'http://api.example.com/users?page=5'
     * });
     */
    links(links: any): this;
    /**
     * Send a response.
     * @example
     * res.send(Buffer.from('wahoo'));
     * res.send({ some: 'json' });
     * res.send('<p>some html</p>');
     */
    send(body: any): any;
    /**
     * Send JSON response.
     * @example
     * res.json(null);
     * res.json({ user: 'tj' });
     * res.status(500).json('oh noes!');
     * res.status(404).json('I dont have that');
     */
    json(obj: any): any;
    /**
     * Send JSON response with JSONP callback support.
     * @example
     * res.jsonp(null);
     * res.jsonp({ user: 'tj' });
     * res.status(500).jsonp('oh noes!');
     * res.status(404).jsonp('I dont have that');
     */
    jsonp(obj: any): any;
    /**
     * Send given HTTP status code.
     *
     * Sets the response status to `statusCode` and the body of the
     * response to the standard description from node's http.STATUS_CODES
     * or the statusCode number if no description.
  
     * @example
     *
     * res.sendStatus(200); // equivalent to res.status(200).send('OK')
     * res.sendStatus(403); // equivalent to res.status(403).send('Forbidden')
     * res.sendStatus(404); // equivalent to res.status(404).send('Not Found')
     * res.sendStatus(500); // equivalent to res.status(500).send('Internal Server Error')
     */
    sendStatus(statusCode: any): any;
    /**
     * Transfer the file at the given `path`.
     *
     * Automatically sets the _Content-Type_ response header field.
     * The callback `callback(err)` is invoked when the transfer is complete
     * or when an error occurs. Be sure to check `res.headersSent`
     * if you wish to attempt responding, as the header and some data
     * may have already been transferred.
     *
     * Options:
     *
     *   - `maxAge`   defaulting to 0 (can be string converted by `ms`)
     *   - `root`     root directory for relative filenames
     *   - `headers`  object of headers to serve with file
     *   - `dotfiles` serve dotfiles, defaulting to false; can be `"allow"` to send them
     *
     * Other options are passed along to `send`.
     *
     * @example
     *
     *  `The following example illustrates how `res.sendFile()` may
     *  be used as an alternative for the `static()` middleware for
     *  dynamic situations. The code backing `res.sendFile()` is actually
     *  the same code, so HTTP cache support etc is identical.`
     *
     *  app.get('/user/:uid/photos/:file', (req, res) => {
     *    const { uid, file } = req.params
     *
     *    req.user.mayViewFilesFrom(uid, (yes) => {
     *      if (yes) {
     *        res.sendFile('/uploads/' + uid + '/' + file)
     *      } else {
     *        res.send(403, 'Sorry! you cant see that.')
     *      }
     *    })
     *  })
     */
    sendFile(path: any, options: any, callback: any): void;
    /**
     * Transfer the file at the given `path` as an attachment.
     *
     * Optionally providing an alternate attachment `filename`,
     * and optional callback `callback(err)`. The callback is invoked
     * when the data transfer is complete, or when an error has
     * ocurred. Be sure to check `res.headersSent` if you plan to respond.
     *
     * Optionally providing an `options` object to use with `res.sendFile()`.
     * This function will set the `Content-Disposition` header, overriding
     * any `Content-Disposition` header passed as header options in order
     * to set the attachment and filename.
     *
     * This method uses `res.sendFile()`.
     */
    download(path: any, filename: any, options: any, callback: any): void;
    /**
     * Set _Content-Type_ response header with `type` through `mime.lookup()`
     * when it does not contain "/", or set the Content-Type to `type` otherwise.
     * @example
     * res.type('.html');
     * res.type('html');
     * res.type('json');
     * res.type('application/json');
     * res.type('png');
     */
    contentType(type: string): this;
    type(type: any): this;
    /**
     * Respond to the Acceptable formats using an `obj`
     * of mime-type callbacks.
     *
     * This method uses `req.accepted`, an array of
     * acceptable types ordered by their quality values.
     * When "Accept" is not present the _first_ callback
     * is invoked, otherwise the first match is used. When
     * no match is performed the server responds with
     * 406 "Not Acceptable".
     *
     * Content-Type is set for you, however if you choose
     * you may alter this within the callback using `res.type()`
     * or `res.set('Content-Type', ...)`.
     *
     * @example
     *
     * res.format({
     *   'text/plain': () => {
     *     res.send('hey')
     *   },
     *   'text/html': () => {
     *     res.send('<p>hey</p>')
     *   },
     *   'application/json': () => {
     *     res.send({ message: 'hey' })
     *   }
     * })
     *
     * @description
     *
     * In addition to canonicalized MIME types you may
     * also use extnames mapped to these types:
     *
     * @example
     *
     * res.format({
     *   text: () => {
     *     res.send('hey');
     *   },
     *   html: () => {
     *     res.send('<p>hey</p>')
     *   },
     *   json: () => {
     *     res.send({ message: 'hey' })
     *   }
     * })
     *
     * @description
     *
     * By default Express passes an `Error`
     * with a `.status` of 406 to `next(err)`
     * if a match is not made. If you provide
     * a `.default` callback it will be invoked
     * instead.
     */
    format(obj: any): this;
    /** Set _Content-Disposition_ header to _attachment_ with optional `filename`. */
    attachment(filename: string): this;
    /**
     * Append additional header `field` with value `val`.
     * @example
     * res.append('Link', ['<http://localhost/>', '<http://localhost:3000/>'])
     * res.append('Set-Cookie', 'foo=bar; Path=/; HttpOnly')
     * res.append('Warning', '199 Miscellaneous warning')
     */
    append(field: string, val: string | string[]): this;
    /**
     * Set header `field` to `val`, or pass
     * an object of header fields.
     *
     * @example
     * res.set('Foo', ['bar', 'baz'])
     * res.set('Accept', 'application/json')
     * res.set({ Accept: 'text/plain', 'X-API-Key': 'tobi' })
     *
     * @description
     * Aliased as `res.header()`.
     *
     * @param {String|Object} field
     * @param {String|Array} val
     */
    header(field: any, val: any): this;
    /** same as "this.header()" */
    set(field: any, val: any): this;
    /** Get value for header `field`. */
    get(field: string): string | number | string[] | undefined;
    /** Clear cookie `name`. */
    clearCookie(name: string, options: any): this;
    /**
     * Set cookie `name` to `value`, with the given `options`.
     *
     * Options:
     *
     *    - `maxAge`   max-age in milliseconds, converted to `expires`
     *    - `signed`   sign the cookie
     *    - `path`     defaults to "/"
     *
     * Examples:
     *
     *    // "Remember Me" for 15 minutes
     *    res.cookie('rememberme', '1', { expires: new Date(Date.now() + 900000), httpOnly: true });
     *
     *    // same as above
     *    res.cookie('rememberme', '1', { maxAge: 900000, httpOnly: true })
     */
    cookie(name: string, value: string | Object, options?: {
        expires?: Date;
        maxAge?: number;
        signed?: boolean;
        path?: string;
    }): this;
    /**
     * Set the location header to `url`.
     *
     * The given `url` can also be "back", which redirects
     * to the _Referrer_ or _Referer_ headers or "/".
     *
     * Examples:
     *
     *    res.location('/foo/bar').;
     *    res.location('http://example.com');
     *    res.location('../login');
     */
    location(url: string): this;
    /**
     * Redirect to the given `url` with optional response `status`
     * defaulting to 302.
     *
     * The resulting `url` is determined by `res.location()`, so
     * it will play nicely with mounted apps, relative paths,
     * `"back"` etc.
     *
     * Examples:
     *
     *    res.redirect('/foo/bar');
     *    res.redirect('http://example.com');
     *    res.redirect(301, 'http://example.com');
     *    res.redirect('../login'); // /blog/post/1 -> /blog/login
     */
    redirect(url: any): void;
    /**
     * Add `field` to Vary. If already present in the Vary set, then
     * this call is simply ignored.
     *
     * @param {Array|String} field
     * @return {ServerResponse} for chaining
     * @public
     */
    vary(field: any): this;
    /**
     * Render `view` with the given `options` and optional callback `fn`.
     * When a callback function is given a response will _not_ be made
     * automatically, otherwise a response of _200_ and _text/html_ is given.
     *
     * Options:
     *
     *  - `cache`     boolean hinting to the engine it should cache
     *  - `filename`  filename of the view being rendered
     */
    render(view: any, options: any, callback: any): void;
}
export declare const res: Response;
export {};
