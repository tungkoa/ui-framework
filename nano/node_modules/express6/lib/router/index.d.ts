/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * Copyright(c) 2021 Yannick Deubel (https://github.com/yandeu)
 * MIT Licensed
 */
import { RESTFunction, RequestHandler } from '../types.js';
import { ExtensibleFunction } from '../utils.js';
import { Route } from './route.js';
interface RouterOptions {
    caseSensitive?: boolean;
    mergeParams?: boolean;
    strict?: boolean;
}
/**
 * Initialize a new `Router` with the given `options`.
 *
 * @param {Object} [options]
 * @return {Router} which is an callable function
 */
declare class Router extends ExtensibleFunction<RequestHandler> {
    _params: any;
    params: any;
    stack: any[];
    mergeParams: boolean;
    caseSensitive: boolean;
    strict: boolean;
    get: RESTFunction;
    post: RESTFunction;
    put: RESTFunction;
    patch: RESTFunction;
    delete: RESTFunction;
    copy: RESTFunction;
    head: RESTFunction;
    options: RESTFunction;
    constructor(options?: RouterOptions);
    /**
     * Map the given param placeholder `name`(s) to the given callback.
     *
     * Parameter mapping is used to provide pre-conditions to routes
     * which use normalized placeholders. For example a _:user_id_ parameter
     * could automatically load a user's information from the database without
     * any additional code,
     *
     * The callback uses the same signature as middleware, the only difference
     * being that the value of the placeholder is passed, in this case the _id_
     * of the user. Once the `next()` function is invoked, just like middleware
     * it will continue on to execute the route, or subsequent parameter functions.
     *
     * Just like in middleware, you must either respond to the request or call next
     * to avoid stalling the request.
     *
     * @example
     * app.param('user_id', function (req, res, next, id) {
     *   User.find(id, function (err, user) {
     *     if (err) {
     *       return next(err)
     *     } else if (!user) {
     *       return next(new Error('failed to load user'))
     *     }
     *     req.user = user
     *     next()
     *   })
     * })
     */
    param(name: string, fn: Function): this;
    /** Dispatch a req, res into the router. */
    private handle;
    /** Process any parameters for the layer. */
    private process_params;
    /**
     * Use the given middleware function, with optional path, defaulting to "/".
     *
     * Use (like `.all`) will run for any http METHOD, but it will not add
     * handlers for those methods so OPTIONS requests will not consider `.use`
     * functions even if they could respond.
     *
     * The other difference is that _route_ path is stripped and not visible
     * to the handler function. The main effect of this feature is that mounted
     * handlers can operate without any code changes regardless of the "prefix"
     * pathname.
     */
    use(fn: any): this;
    /**
     * Create a new Route for the given path.
     *
     * Each route contains a separate middleware stack and VERB handlers.
     *
     * See the Route api documentation for details on adding handlers
     * and middleware to routes.
     */
    route(path: string): Route;
}
export default Router;
export { Router };
