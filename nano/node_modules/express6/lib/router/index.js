"use strict";
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * Copyright(c) 2021 Yannick Deubel (https://github.com/yandeu)
 * MIT Licensed
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Router = void 0;
const utils_js_1 = require("../utils.js");
const layer_js_1 = require("./layer.js");
const route_js_1 = require("./route.js");
const debug_1 = __importDefault(require("debug"));
const methods_1 = __importDefault(require("methods"));
const array_flatten_1 = require("array-flatten");
const utils_merge_1 = __importDefault(require("utils-merge"));
const parseurl_1 = __importDefault(require("parseurl"));
const methods = [...methods_1.default, 'all'];
const debug = (0, debug_1.default)('express:router');
const objectRegExp = /^\[object (\S+)\]$/;
const slice = Array.prototype.slice;
const toString = Object.prototype.toString;
/**
 * Initialize a new `Router` with the given `options`.
 *
 * @param {Object} [options]
 * @return {Router} which is an callable function
 */
class Router extends utils_js_1.ExtensibleFunction {
    constructor(options = {}) {
        super((req, res, next) => {
            return this.handle(req, res, next);
        });
        this._params = {};
        this.params = {};
        this.stack = [];
        const { caseSensitive = false, mergeParams = false, strict = false } = options;
        this.caseSensitive = caseSensitive;
        this.mergeParams = mergeParams;
        this.strict = strict;
    }
    /**
     * Map the given param placeholder `name`(s) to the given callback.
     *
     * Parameter mapping is used to provide pre-conditions to routes
     * which use normalized placeholders. For example a _:user_id_ parameter
     * could automatically load a user's information from the database without
     * any additional code,
     *
     * The callback uses the same signature as middleware, the only difference
     * being that the value of the placeholder is passed, in this case the _id_
     * of the user. Once the `next()` function is invoked, just like middleware
     * it will continue on to execute the route, or subsequent parameter functions.
     *
     * Just like in middleware, you must either respond to the request or call next
     * to avoid stalling the request.
     *
     * @example
     * app.param('user_id', function (req, res, next, id) {
     *   User.find(id, function (err, user) {
     *     if (err) {
     *       return next(err)
     *     } else if (!user) {
     *       return next(new Error('failed to load user'))
     *     }
     *     req.user = user
     *     next()
     *   })
     * })
     */
    param(name, fn) {
        if (!fn) {
            throw new TypeError('argument fn is required');
        }
        if (typeof fn !== 'function') {
            throw new TypeError('argument fn must be a function');
        }
        let params = this.params[name];
        if (!params) {
            params = this.params[name] = [];
        }
        params.push(fn);
        return this;
    }
    /** Dispatch a req, res into the router. */
    handle(req, res, out) {
        const self = this;
        debug('dispatching %s %s', req.method, req.url);
        let idx = 0;
        const protohost = getProtohost(req.url) || '';
        let removed = '';
        let slashAdded = false;
        const paramcalled = {};
        // store options for OPTIONS request
        // only used if OPTIONS request
        const options = [];
        // middleware and routes
        const stack = self.stack;
        // manage inter-router variables
        const parentParams = req.params;
        const parentUrl = req.baseUrl || '';
        // @ts-ignore
        let done = restore(out, req, 'baseUrl', 'next', 'params');
        // setup next layer
        req.next = next;
        // for options requests, respond with a default if nothing else responds
        if (req.method === 'OPTIONS') {
            done = wrap(done, function (old, err) {
                if (err || options.length === 0)
                    return old(err);
                sendOptionsResponse(res, options, old);
            });
        }
        // setup basic req values
        req.baseUrl = parentUrl;
        req.originalUrl = req.originalUrl || req.url;
        next();
        function next(err) {
            let layerError = err === 'route' ? null : err;
            // remove added slash
            if (slashAdded) {
                req.url = req.url.substring(1);
                slashAdded = false;
            }
            // restore altered req.url
            if (removed.length !== 0) {
                req.baseUrl = parentUrl;
                req.url = protohost + removed + req.url.substring(protohost.length);
                removed = '';
            }
            // signal to exit router
            if (layerError === 'router') {
                setImmediate(done, null);
                return;
            }
            // no more matching layers
            if (idx >= stack.length) {
                setImmediate(done, layerError);
                return;
            }
            // get pathname of request
            const path = getPathname(req);
            if (path == null) {
                return done(layerError);
            }
            // find next matching layer
            let layer;
            let match;
            let route;
            while (match !== true && idx < stack.length) {
                layer = stack[idx++];
                match = matchLayer(layer, path);
                route = layer.route;
                if (typeof match !== 'boolean') {
                    // hold on to layerError
                    layerError = layerError || match;
                }
                if (match !== true) {
                    continue;
                }
                if (!route) {
                    // process non-route handlers normally
                    continue;
                }
                if (layerError) {
                    // routes do not match with a pending error
                    match = false;
                    continue;
                }
                const method = req.method;
                const has_method = route._handles_method(method);
                // build up automatic options response
                if (!has_method && method === 'OPTIONS') {
                    appendMethods(options, route._options());
                }
                // don't even bother matching route
                if (!has_method && method !== 'HEAD') {
                    match = false;
                    continue;
                }
            }
            // no match
            if (match !== true) {
                return done(layerError);
            }
            // store route for dispatch on change
            if (route) {
                req.route = route;
            }
            // Capture one-time layer values
            req.params = self.mergeParams ? mergeParams(layer.params, parentParams) : layer.params;
            const layerPath = layer.path;
            // this should be done for the layer
            self.process_params(layer, paramcalled, req, res, function (err) {
                if (err) {
                    return next(layerError || err);
                }
                if (route) {
                    return layer.handle_request(req, res, next);
                }
                trim_prefix(layer, layerError, layerPath, path);
            });
        }
        function trim_prefix(layer, layerError, layerPath, path) {
            if (layerPath.length !== 0) {
                // Validate path breaks on a path separator
                const c = path[layerPath.length];
                if (c && c !== '/' && c !== '.')
                    return next(layerError);
                // Trim off the part of the url that matches the route
                // middleware (.use stuff) needs to have the path stripped
                debug('trim prefix (%s) from url %s', layerPath, req.url);
                removed = layerPath;
                req.url = protohost + req.url.substring(protohost.length + removed.length);
                // Ensure leading slash
                if (!protohost && req.url[0] !== '/') {
                    req.url = `/${req.url}`;
                    slashAdded = true;
                }
                // Setup base URL (no trailing slash)
                req.baseUrl =
                    parentUrl + (removed[removed.length - 1] === '/' ? removed.substring(0, removed.length - 1) : removed);
            }
            debug('%s %s : %s', layer.name, layerPath, req.originalUrl);
            if (layerError) {
                layer.handle_error(layerError, req, res, next);
            }
            else {
                layer.handle_request(req, res, next);
            }
        }
    }
    /** Process any parameters for the layer. */
    process_params(layer, called, req, res, done) {
        const params = this.params;
        // captured parameters from the layer, keys and values
        const keys = layer.keys;
        // fast track
        if (!keys || keys.length === 0) {
            return done();
        }
        let i = 0;
        let name;
        let paramIndex = 0;
        let key;
        let paramVal;
        let paramCallbacks;
        let paramCalled;
        // process params in order
        // param callbacks can be async
        function param(err) {
            if (err) {
                return done(err);
            }
            if (i >= keys.length) {
                return done();
            }
            paramIndex = 0;
            key = keys[i++];
            name = key.name;
            paramVal = req.params[name];
            paramCallbacks = params[name];
            paramCalled = called[name];
            if (paramVal === undefined || !paramCallbacks) {
                return param();
            }
            // param previously called with same value or error occurred
            if (paramCalled && (paramCalled.match === paramVal || (paramCalled.error && paramCalled.error !== 'route'))) {
                // restore value
                req.params[name] = paramCalled.value;
                // next param
                return param(paramCalled.error);
            }
            called[name] = paramCalled = {
                error: null,
                match: paramVal,
                value: paramVal
            };
            paramCallback();
        }
        // single param callbacks
        function paramCallback(err) {
            const fn = paramCallbacks[paramIndex++];
            // store updated value
            paramCalled.value = req.params[key.name];
            if (err) {
                // store error
                paramCalled.error = err;
                param(err);
                return;
            }
            if (!fn)
                return param();
            try {
                fn(req, res, paramCallback, paramVal, key.name);
            }
            catch (e) {
                paramCallback(e);
            }
        }
        param();
    }
    /**
     * Use the given middleware function, with optional path, defaulting to "/".
     *
     * Use (like `.all`) will run for any http METHOD, but it will not add
     * handlers for those methods so OPTIONS requests will not consider `.use`
     * functions even if they could respond.
     *
     * The other difference is that _route_ path is stripped and not visible
     * to the handler function. The main effect of this feature is that mounted
     * handlers can operate without any code changes regardless of the "prefix"
     * pathname.
     */
    use(fn) {
        let offset = 0;
        let path = '/';
        // default path to '/'
        // disambiguate router.use([fn])
        if (typeof fn !== 'function') {
            let arg = fn;
            while (Array.isArray(arg) && arg.length !== 0) {
                arg = arg[0];
            }
            // first arg is the path
            if (typeof arg !== 'function') {
                offset = 1;
                path = fn;
            }
        }
        const callbacks = (0, array_flatten_1.flatten)(slice.call(arguments, offset));
        if (callbacks.length === 0) {
            throw new TypeError('Router.use() requires a middleware function');
        }
        for (let i = 0; i < callbacks.length; i++) {
            const fn = callbacks[i];
            if (typeof fn !== 'function') {
                throw new TypeError(`Router.use() requires a middleware function but got a ${gettype(fn)}`);
            }
            // add the middleware
            debug('use %o %s', path, fn.name || '<anonymous>');
            const layer = new layer_js_1.Layer(path, {
                sensitive: this.caseSensitive,
                strict: false,
                end: false
            }, fn);
            layer.route = undefined;
            this.stack.push(layer);
        }
        return this;
    }
    /**
     * Create a new Route for the given path.
     *
     * Each route contains a separate middleware stack and VERB handlers.
     *
     * See the Route api documentation for details on adding handlers
     * and middleware to routes.
     */
    route(path) {
        const route = new route_js_1.Route(path);
        const layer = new layer_js_1.Layer(path, {
            sensitive: this.caseSensitive,
            strict: this.strict,
            end: true
        }, 
        // @ts-ignore
        route.dispatch.bind(route));
        layer.route = route;
        this.stack.push(layer);
        return route;
    }
}
exports.Router = Router;
// create Router#VERB functions
methods.concat('all').forEach(function (method) {
    // @ts-ignore
    Router.prototype[method] = function (path) {
        const route = this.route(path);
        // eslint-disable-next-line prefer-spread
        route[method].apply(route, slice.call(arguments, 1));
        return this;
    };
});
// append methods to a list of methods
function appendMethods(list, addition) {
    for (let i = 0; i < addition.length; i++) {
        const method = addition[i];
        if (list.indexOf(method) === -1) {
            list.push(method);
        }
    }
}
// get pathname of request
function getPathname(req) {
    var _a;
    try {
        return (_a = (0, parseurl_1.default)(req)) === null || _a === void 0 ? void 0 : _a.pathname;
    }
    catch (err) {
        return undefined;
    }
}
// Get get protocol + host for a URL
function getProtohost(url) {
    if (typeof url !== 'string' || url.length === 0 || url[0] === '/') {
        return undefined;
    }
    const searchIndex = url.indexOf('?');
    const pathLength = searchIndex !== -1 ? searchIndex : url.length;
    const fqdnIndex = url.substring(0, pathLength).indexOf('://');
    return fqdnIndex !== -1 ? url.substring(0, url.indexOf('/', 3 + fqdnIndex)) : undefined;
}
// get type for error message
function gettype(obj) {
    const type = typeof obj;
    if (type !== 'object') {
        return type;
    }
    // inspect [[Class]] for objects
    return toString.call(obj).replace(objectRegExp, '$1');
}
/** Match path to a layer. */
function matchLayer(layer, path) {
    try {
        return layer.match(path);
    }
    catch (err) {
        return err;
    }
}
// merge params with parent params
function mergeParams(params, parent) {
    if (typeof parent !== 'object' || !parent) {
        return params;
    }
    // make copy of parent for base
    const obj = (0, utils_merge_1.default)({}, parent);
    // simple non-numeric merging
    if (!(0 in params) || !(0 in parent)) {
        return (0, utils_merge_1.default)(obj, params);
    }
    let i = 0;
    let o = 0;
    // determine numeric gaps
    while (i in params) {
        i++;
    }
    while (o in parent) {
        o++;
    }
    // offset numeric indices in params before merge
    for (i--; i >= 0; i--) {
        params[i + o] = params[i];
        // create holes for the merge when necessary
        if (i < o) {
            delete params[i];
        }
    }
    return (0, utils_merge_1.default)(obj, params);
}
// restore obj props after function
function restore(fn, obj) {
    const props = new Array(arguments.length - 2);
    const vals = new Array(arguments.length - 2);
    for (let i = 0; i < props.length; i++) {
        props[i] = arguments[i + 2];
        vals[i] = obj[props[i]];
    }
    const _this = this;
    return function () {
        // restore vals
        for (let i = 0; i < props.length; i++) {
            obj[props[i]] = vals[i];
        }
        return fn.apply(_this, arguments);
    };
}
// send an OPTIONS response
function sendOptionsResponse(res, options, next) {
    try {
        const body = options.join(',');
        res.set('Allow', body);
        res.send(body);
    }
    catch (err) {
        next(err);
    }
}
// wrap a function
function wrap(old, fn) {
    const _this = this;
    return function proxy() {
        const args = new Array(arguments.length + 1);
        args[0] = old;
        for (let i = 0, len = arguments.length; i < len; i++) {
            args[i + 1] = arguments[i];
        }
        fn.apply(_this, args);
    };
}
exports.default = Router;
//# sourceMappingURL=index.js.map