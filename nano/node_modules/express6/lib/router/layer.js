"use strict";
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * Copyright(c) 2021 Yannick Deubel (https://github.com/yandeu)
 * MIT Licensed
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Layer = void 0;
const debug_1 = __importDefault(require("debug"));
const path_to_regexp_1 = __importDefault(require("path-to-regexp"));
const debug = (0, debug_1.default)('express:router:layer');
const hasOwnProperty = Object.prototype.hasOwnProperty;
// handle UnhandledPromiseRejection
const isPromise = (val) => val && typeof val === 'object' && typeof val.then === 'function' && typeof val.catch === 'function';
class Layer {
    constructor(path, options, fn) {
        this.keys = [];
        debug('new %o', path);
        const opts = options || {};
        this.handle = fn;
        this.name = fn.name || '<anonymous>';
        this.params = undefined;
        this.path = undefined;
        this.regexp = (0, path_to_regexp_1.default)(path, (this.keys = []), opts);
        // set fast path flags
        this.regexp.fast_star = path === '*';
        // @ts-ignore
        this.regexp.fast_slash = path === '/' && opts.end === false;
    }
    /** Handle the error for the layer. */
    handle_error(error, req, res, next) {
        const fn = this.handle;
        if (fn.length !== 4) {
            // not a standard error handler
            return next(error);
        }
        // handle UnhandledPromiseRejection
        try {
            // invoke function
            const ret = fn(error, req, res, next);
            // wait for returned promise
            if (isPromise(ret)) {
                ret.then(null, function (error) {
                    next(error || new Error('Rejected promise'));
                });
            }
        }
        catch (err) {
            next(err);
        }
    }
    /** Handle the request for the layer. */
    handle_request(req, res, next) {
        const fn = this.handle;
        if (fn.length > 3) {
            // not a standard request handler
            return next();
        }
        // handle UnhandledPromiseRejection
        try {
            // invoke function
            const ret = fn(req, res, next);
            // wait for returned promise
            if (isPromise(ret)) {
                ret.then(null, function (error) {
                    next(error || new Error('Rejected promise'));
                });
            }
        }
        catch (err) {
            next(err);
        }
    }
    /**
     * Check if this route matches `path`, if so
     * populate `.params`.
     */
    match(path) {
        let match;
        if (path != null) {
            // fast path non-ending match for / (any path matches)
            if (this.regexp.fast_slash) {
                this.params = {};
                this.path = '';
                return true;
            }
            // fast path for * (everything matched in a param)
            if (this.regexp.fast_star) {
                this.params = { 0: decode_param(path) };
                this.path = path;
                return true;
            }
            match = this.regexp.exec(path);
        }
        if (!match) {
            this.params = undefined;
            this.path = undefined;
            return false;
        }
        // store values
        this.params = {};
        this.path = match[0];
        const keys = this.keys;
        const params = this.params;
        for (let i = 1; i < match.length; i++) {
            const key = keys[i - 1];
            const prop = key.name;
            const val = decode_param(match[i]);
            if (val !== undefined || !hasOwnProperty.call(params, prop)) {
                params[prop] = val;
            }
        }
        return true;
    }
}
exports.Layer = Layer;
/** Decode param value. */
function decode_param(val) {
    if (typeof val !== 'string' || val.length === 0) {
        return val;
    }
    try {
        return decodeURIComponent(val);
    }
    catch (err) {
        if (err instanceof URIError) {
            err.message = `Failed to decode param '${val}'`;
            // @ts-ignore
            err.status = err.statusCode = 400;
        }
        throw err;
    }
}
//# sourceMappingURL=layer.js.map