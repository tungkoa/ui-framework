"use strict";
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * Copyright(c) 2021 Yannick Deubel (https://github.com/yandeu)
 * MIT Licensed
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.applyMixins = exports.ExtensibleFunction = exports.setCharset = exports.compileTrust = exports.compileQueryParser = exports.compileETag = exports.normalizeTypes = exports.normalizeType = exports.wetag = exports.etag = void 0;
const etag_1 = __importDefault(require("etag"));
const content_type_1 = __importDefault(require("content-type"));
const send_1 = require("send");
const proxy_addr_1 = __importDefault(require("proxy-addr"));
const qs_1 = __importDefault(require("qs"));
const querystring_1 = __importDefault(require("querystring"));
/** Split and trim a string */
const splitAndTrim = (str, splitter) => {
    return str.split(splitter).map(v => v.trim());
};
/**
 * Create an ETag generator function, generating ETags with
 * the given options.
 */
const createETagGenerator = (options) => {
    return (body, encoding) => {
        const buf = !Buffer.isBuffer(body) ? Buffer.from(body, encoding) : body;
        return (0, etag_1.default)(buf, options);
    };
};
/** Parse an extended query string with qs. */
const parseExtendedQueryString = (str) => {
    return qs_1.default.parse(str, {
        allowPrototypes: true
    });
};
/**
 * Return strong ETag for `body`.
 *
 * @param {String|Buffer} body
 * @param {String} [encoding]
 * @return {String}
 * @api private
 */
exports.etag = createETagGenerator({ weak: false });
/**
 * Return weak ETag for `body`.
 *
 * @param {String|Buffer} body
 * @param {String} [encoding]
 * @return {String}
 * @api private
 */
exports.wetag = createETagGenerator({ weak: true });
/** Normalize the given `type`, for example "html" becomes "text/html". */
const normalizeType = (type) => {
    return ~type.indexOf('/') ? acceptParams(type) : { value: send_1.mime.lookup(type), params: {} };
};
exports.normalizeType = normalizeType;
/** Normalize `types`, for example "html" becomes "text/html". */
const normalizeTypes = (types) => {
    const ret = [];
    for (let i = 0; i < types.length; ++i) {
        ret.push((0, exports.normalizeType)(types[i]));
    }
    return ret;
};
exports.normalizeTypes = normalizeTypes;
/**
 * Parse accept params `str` returning an
 * object with `.value`, `.quality` and `.params`.
 * also includes `.originalIndex` for stable sorting
 *
 * @param {String} str
 * @return {Object}
 * @api private
 */
const acceptParams = (str, index) => {
    const parts = splitAndTrim(str, ';');
    const ret = { value: parts[0], quality: 1, params: {}, originalIndex: index };
    for (let i = 1; i < parts.length; ++i) {
        const pms = splitAndTrim(parts[i], '=');
        if ('q' === pms[0]) {
            ret.quality = parseFloat(pms[1]);
        }
        else {
            ret.params[pms[0]] = pms[1];
        }
    }
    return ret;
};
/** Compile "etag" value to function. */
const compileETag = (val) => {
    let fn;
    if (typeof val === 'function') {
        return val;
    }
    switch (val) {
        case true:
        case 'weak':
            fn = exports.wetag;
            break;
        case false:
            break;
        case 'strong':
            fn = exports.etag;
            break;
        default:
            throw new TypeError(`unknown value for etag function: ${val}`);
    }
    return fn;
};
exports.compileETag = compileETag;
/** Compile "query parser" value to function. */
const compileQueryParser = (val) => {
    let fn;
    if (typeof val === 'function') {
        return val;
    }
    switch (val) {
        case true:
        case 'simple':
            fn = querystring_1.default.parse;
            break;
        case false:
            break;
        case 'extended':
            fn = parseExtendedQueryString;
            break;
        default:
            throw new TypeError(`unknown value for query parser function: ${val}`);
    }
    return fn;
};
exports.compileQueryParser = compileQueryParser;
/** Compile "proxy trust" value to function. */
const compileTrust = (val) => {
    if (typeof val === 'function')
        return val;
    if (val === true) {
        // Support plain true/false
        return () => {
            return true;
        };
    }
    if (typeof val === 'number') {
        // Support trusting hop count
        return (_a, i) => {
            return i < val;
        };
    }
    if (typeof val === 'string') {
        // Support comma-separated values
        val = splitAndTrim(val, ',');
    }
    return proxy_addr_1.default.compile(val || []);
};
exports.compileTrust = compileTrust;
/**
 * Set the charset in a given Content-Type string.
 *
 * @param {String} type
 * @param {String} charset
 * @return {String}
 * @api private
 */
const setCharset = (type, charset) => {
    if (!type || !charset) {
        return type;
    }
    // parse type
    const parsed = content_type_1.default.parse(type);
    // set charset
    parsed.parameters.charset = charset;
    // format type
    return content_type_1.default.format(parsed);
};
exports.setCharset = setCharset;
class ExtensibleFunction extends Function {
    constructor(f) {
        super();
        return Object.setPrototypeOf(f, new.target.prototype);
    }
}
exports.ExtensibleFunction = ExtensibleFunction;
// https://www.typescriptlang.org/docs/handbook/mixins.html
const applyMixins = (derivedCtor, constructors) => {
    constructors.forEach(baseCtor => {
        Object.getOwnPropertyNames(baseCtor.prototype).forEach(name => {
            Object.defineProperty(derivedCtor.prototype, name, Object.getOwnPropertyDescriptor(baseCtor.prototype, name) || Object.create(null));
        });
    });
};
exports.applyMixins = applyMixins;
//# sourceMappingURL=utils.js.map