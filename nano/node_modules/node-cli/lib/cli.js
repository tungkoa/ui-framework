"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.write = exports.clearDisplay = exports.clear = exports.clearLastLine = exports.cursor = exports.showCursor = exports.hideCursor = exports._clearLinesDown = exports._clearLastLine = exports.cursorTo = exports.clearLine = exports.moveCursor = exports.rows = exports.lines = void 0;
const readline_1 = __importDefault(require("readline"));
// keep track of lines
let _lines = 0;
const lines = () => {
    return _lines;
};
exports.lines = lines;
const rows = () => {
    return process.stdout.rows;
};
exports.rows = rows;
const moveCursor = (dx, dy) => {
    return new Promise(resolve => {
        process.stdout.moveCursor(dx, dy, () => {
            resolve();
        });
    });
};
exports.moveCursor = moveCursor;
/* Clears the current line of this WriteStream in a direction identified by dir. */
const clearLine = (dir) => {
    return new Promise(resolve => {
        process.stdout.clearLine(dir, () => {
            resolve();
        });
    });
};
exports.clearLine = clearLine;
const cursorTo = (x, y) => {
    return new Promise(resolve => {
        process.stdout.cursorTo(x, y, () => {
            resolve();
        });
    });
};
exports.cursorTo = cursorTo;
const _clearLastLine = () => {
    return new Promise(resolve => {
        if (_lines === 0)
            return resolve();
        // up one line
        process.stdout.moveCursor(0, -1, () => {
            // move to left
            process.stdout.cursorTo(0, undefined, () => {
                // clear from cursor to end
                process.stdout.clearLine(1, () => {
                    _lines--;
                    resolve();
                });
            });
        });
    });
};
exports._clearLastLine = _clearLastLine;
const _clearLinesDown = (lines) => {
    return new Promise(resolve => {
        if (_lines === 0)
            return resolve();
        // up one line
        process.stdout.moveCursor(0, -lines, () => {
            // move to left
            process.stdout.cursorTo(0, undefined, () => {
                // clear from cursor to end
                process.stdout.clearScreenDown(() => {
                    _lines -= lines;
                    resolve();
                });
            });
        });
    });
};
exports._clearLinesDown = _clearLinesDown;
const hideCursor = () => {
    exports.cursor(false);
};
exports.hideCursor = hideCursor;
const showCursor = () => {
    exports.cursor(true);
};
exports.showCursor = showCursor;
const cursor = (visible) => {
    process.stdout.write(visible ? '\u001B[?25h' : '\u001B[?25l');
};
exports.cursor = cursor;
/** Same as clear(1) */
const clearLastLine = async () => {
    await exports.clear(1);
};
exports.clearLastLine = clearLastLine;
const clear = async (count = 0) => {
    if (_lines === 0)
        return;
    if (count < 0)
        count = _lines + count;
    const toRemove = _lines - count;
    if (toRemove < 0)
        return;
    // removes all lines in one run
    if (count > 0)
        await exports._clearLinesDown(_lines - toRemove);
    else
        await exports._clearLinesDown(_lines - count);
    // removes line by line
    // if (count > 0) while (_lines > toRemove) await _clearLastLine()
    // else while (_lines > count) await _clearLastLine()
};
exports.clear = clear;
const clearDisplay = () => {
    return new Promise(resolve => {
        readline_1.default.cursorTo(process.stdout, 0, 0); //  CSI`${y + 1};${x + 1}H`; // \u001b[0;0H"
        // console.log('\u001b[0;0H')
        readline_1.default.clearScreenDown(process.stdout, () => {
            // \u001b[0J
            _lines = 0;
            resolve();
        });
        // console.log('\u001b[0J') // clearScreenDown
        // console.log('\u001b[2J') // clearDisplay
    });
};
exports.clearDisplay = clearDisplay;
const write = (...data) => {
    const d = data.join(' ');
    const count = (str) => {
        var _a;
        return ((_a = str.match(/\n/gm)) === null || _a === void 0 ? void 0 : _a.length) || 0;
    };
    const newLines = count(d) + 1;
    _lines += newLines;
    process.stdout.write(`${d}\n`);
    return newLines;
};
exports.write = write;
