"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.publish = void 0;
const node_cli_1 = require("node-cli");
const utils_1 = require("./utils");
const components_1 = require("node-cli/lib/jsx/components");
const core_1 = require("node-cli/lib/jsx/core");
const AddTag_1 = require("./steps/AddTag");
const CommitMessage_1 = require("./steps/CommitMessage");
const ExecuteHooks_1 = require("./steps/ExecuteHooks");
const ReleaseVersion_1 = require("./steps/ReleaseVersion");
const UpdatePkg_1 = require("./steps/UpdatePkg");
const readline_1 = __importDefault(require("readline"));
node_cli_1.hideCursor();
const publish = () => __awaiter(void 0, void 0, void 0, function* () {
    let didCommit = false;
    let pushToGit = false;
    let tag;
    let pushTag = '';
    let publishToNpm = '';
    // const options = ['burger', 'pizza', 'spag', 'more', 'crep']
    // const selected = (await render(<MultiSelect question="Select your menu" options={options} />)) as number[]
    // write(`you selected: ${selected}`)
    const pkg = (yield utils_1.readPkg());
    const version = yield core_1.render(core_1.h(ReleaseVersion_1.ReleaseVersion, { version: pkg.version }));
    if (version && version !== 'no' && version !== pkg.version)
        yield core_1.render(core_1.h(UpdatePkg_1.UpdatePkg, { version: version }));
    yield core_1.render(core_1.h(ExecuteHooks_1.ExecuteHooks, { hook: "preReleaseHook" }));
    if (version !== 'no') {
        didCommit = yield core_1.render(core_1.h(components_1.YesNo, { question: `Commit all changes to "v${version}"` }));
        if (didCommit)
            yield CommitMessage_1.CommitMessage(`v${version}`);
        if (didCommit)
            tag = yield core_1.render(core_1.h(AddTag_1.AddTag, { version: version }));
    }
    if (version === 'no') {
        const res = yield core_1.render(core_1.h(components_1.Write, { question: "Your commit message" }));
        yield CommitMessage_1.CommitMessage(res);
        didCommit = true;
    }
    yield core_1.render(core_1.h(ExecuteHooks_1.ExecuteHooks, { hook: "postReleaseHook" }));
    if (didCommit)
        pushToGit = yield core_1.render(core_1.h(components_1.YesNo, { question: "Push to git" }));
    if (didCommit && version !== 'no') {
        const question = tag ? `Push tag "v${version}" to git` : 'Push tag to git';
        pushTag = yield core_1.render(core_1.h(components_1.YesNo, { question: question }));
    }
    if (didCommit && version !== 'no')
        publishToNpm = yield core_1.render(core_1.h(components_1.YesNo, { question: "Publish to npm" }));
    const commands = [];
    if (pushToGit)
        commands.push('git push');
    if (pushTag)
        commands.push('git push --tags');
    if (publishToNpm)
        commands.push('npm publish');
    const cmd = commands.join('; ');
    node_cli_1.write('');
    if (commands.length !== 0) {
        node_cli_1.success('Done! Now run:', null);
        node_cli_1.comment(core_1.h(node_cli_1.Gray, null,
            '  ',
            cmd));
    }
    else {
        node_cli_1.success('Done!', null);
    }
    node_cli_1.write('');
    process.exit(0);
});
exports.publish = publish;
// listen for keypress events
readline_1.default.emitKeypressEvents(process.stdin);
process.stdin.setRawMode(true);
process.stdin.on('keypress', (str, key) => {
    // "Raw" mode so we must do our own kill switch (ctrl + c)
    if (key.sequence === '\u0003') {
        node_cli_1.write(''); // empty line
        process.exit(0);
    }
});
