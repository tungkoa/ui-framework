"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ResponseHttp2 = exports.Response = exports.ResponseBase = void 0;
const fs_1 = require("fs");
const http_1 = require("http");
const promises_1 = require("fs/promises");
const helpers_1 = require("./helpers");
const http2_1 = require("http2");
class ResponseBase {
    status(statusCode) {
        this.statusCode = statusCode;
        return this;
    }
    __send(body, contentType = 'text/plain') {
        // @ts-ignore
        this.writeHead(this.statusCode || 200, { 'Content-Type': contentType });
        // @ts-ignore
        this.end(body);
    }
    get send() {
        return {
            html: (html, addDoctype = false) => {
                this.__send(addDoctype ? (0, helpers_1.makeHtml)(html) : html, 'text/html');
            },
            text: (text) => {
                this.__send(text, 'text/plain');
            },
            json: (json) => {
                this.__send(JSON.stringify(json), 'application/json');
            },
            status: (status) => {
                // end without sending anything (just like nginx)
                if (status === 444) {
                    this.status(444);
                    // @ts-expect-error
                    this.end();
                }
                else {
                    this.status(status).send.text((0, helpers_1.statusCode)(status));
                }
            },
            /**
             * Send a file.
             * Pass a relativePath (without leading slash) or an absolute path
             * Important: Returns a promise; Use "return res.send.file()";
             *
             * @example
             * // absolute path
             * return res.send.file(join(resolve(), 'assets/styles.css')))
             * // relative path
             * return res.send.file('assets/styles.css')
             */
            file: async (filePath) => {
                let isFile = false;
                try {
                    // check file
                    const stats = await (0, promises_1.stat)(filePath);
                    isFile = stats.isFile();
                    if (!isFile)
                        return new Error();
                    // prepare response
                    const contentType = (0, helpers_1.mime)(filePath);
                    // @ts-ignore
                    this.writeHead(200, { 'Content-Type': contentType });
                    // send file
                    // @ts-ignore
                    (0, fs_1.createReadStream)(filePath).pipe(this, { end: true });
                }
                catch (err) {
                    return err;
                }
            }
        };
    }
}
exports.ResponseBase = ResponseBase;
// http/https
class Response extends http_1.ServerResponse {
}
exports.Response = Response;
applyMixins(Response, [ResponseBase]);
// http2
class ResponseHttp2 extends http2_1.Http2ServerResponse {
}
exports.ResponseHttp2 = ResponseHttp2;
applyMixins(ResponseHttp2, [ResponseBase]);
// This can live anywhere in your codebase:
function applyMixins(derivedCtor, constructors) {
    constructors.forEach(baseCtor => {
        Object.getOwnPropertyNames(baseCtor.prototype).forEach(name => {
            Object.defineProperty(derivedCtor.prototype, name, Object.getOwnPropertyDescriptor(baseCtor.prototype, name) || Object.create(null));
        });
    });
}
//# sourceMappingURL=response.js.map