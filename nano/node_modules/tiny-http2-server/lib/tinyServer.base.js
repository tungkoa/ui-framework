"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TinyServerBase = void 0;
const router_1 = require("./router");
const serveStatic_1 = require("./middleware/serveStatic");
const net_1 = require("net");
class TinyServerBase {
    constructor() {
        this.router = new router_1.Router();
        this.sockets = new Map();
        /** alias for this.router.route */
        this.r = this.router.route;
        /** alias for this.router.route */
        this.route = this.router.route;
    }
    /**
     * Serve static files.
     * @param directory Has to be an absolute path.
     */
    static static(directory) {
        return (0, serveStatic_1.serveStatic)(directory);
    }
    portIsFree(port) {
        return new Promise(resolve => {
            const server = (0, net_1.createServer)(function (socket) {
                socket.write('Echo server\r\n');
                socket.pipe(socket);
            });
            server.on('error', function () {
                resolve(false);
            });
            server.on('listening', function () {
                server.close();
                resolve(true);
            });
            server.listen(port, '127.0.0.1');
        });
    }
    async randomPort() {
        const port = Math.floor(Math.random() * (65535 - 1024) + 1024);
        if (await !this.portIsFree(port))
            return this.randomPort();
        else
            return port;
    }
    randomId() {
        return Math.random().toString(32).substring(2) + '-' + Math.random().toString(32).substring(2);
    }
    listen(port = 0) {
        return new Promise(resolve => {
            this.server = this.createServer();
            this.server.on('connection', socket => {
                const randomId = this.randomId();
                if (!this.sockets.has(randomId)) {
                    this.sockets.set(randomId, socket);
                    socket.on('close', () => {
                        this.sockets.delete(randomId);
                    });
                }
            });
            this.server.listen(port, () => {
                // graceful shutdown
                process.on('SIGTERM', async () => {
                    console.log('Server is closing...');
                    await this.close();
                });
                const { port } = this.server.address();
                resolve(port);
            });
        });
    }
    close(force = true, timeout = 2000) {
        return new Promise(resolve => {
            const t = setTimeout(() => {
                if (force) {
                    console.log('Force destroy sockets.');
                    for (const [key, socket] of this.sockets) {
                        socket.destroy();
                    }
                }
            }, timeout);
            this.server.close(() => {
                clearTimeout(t);
                return resolve();
            });
        });
    }
}
exports.TinyServerBase = TinyServerBase;
//# sourceMappingURL=tinyServer.base.js.map